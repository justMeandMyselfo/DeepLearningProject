'''Environment Setup'''
import os
import sys
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, backend as K
from tensorflow.keras.models import Model
from tensorflow.keras.callbacks import LearningRateScheduler, CSVLogger, ModelCheckpoint
from tensorflow.keras.applications.xception import Xception, preprocess_input
from tensorflow.keras.optimizers import SGD

# Set project path and append to sys.path for local imports
project_path = '/content/drive/MyDrive/Training'
if project_path not in sys.path:
    sys.path.append(project_path)

'''Local Imports'''
from custom_validate_callback import CustomCallback
from image_datagenerator import DirectoryDataGenerator
from loupe_keras import NetRVLAD
from RoiPoolingConv import RoiPoolingConv
from SelfAttention import SelfAttention
from SeqAttention import SeqSelfAttention
from SpectralNormalizationKeras import ConvSN2D
from se import squeeze_excite_block

# Path to a previously saved model (e.g. CAP_Xception.20.h5)
checkpoint_path = "/content/drive/MyDrive/CAP_Xception.20.h5"

'''Variables'''
batch_size = 8
checkpoint_freq = 5
dataset_dir = "/content/food-101/food-101/images"
epochs = 200
image_size = (224, 224)
lstm_units = 128
model_name = "CAP_Xception"
nb_classes = 101
optimizer = SGD(learning_rate=0.0001, momentum=0.99, nesterov=True)
train_dir = "/content/food-101/images/train"
val_dir = "/content/food-101/images/val"
validation_freq = 5

os.environ["CUDA_VISIBLE_DEVICES"] = "0"

'''Helper Functions'''
def getROIS(resolution=33, gridSize=3, minSize=1):
    coordsList = []
    step = resolution / gridSize
    for column1 in range(0, gridSize + 1):
        for column2 in range(0, gridSize + 1):
            for row1 in range(0, gridSize + 1):
                for row2 in range(0, gridSize + 1):
                    x0 = int(column1 * step)
                    x1 = int(column2 * step)
                    y0 = int(row1 * step)
                    y1 = int(row2 * step)
                    if x1 > x0 and y1 > y0 and ((x1 - x0) >= (step * minSize) or (y1 - y0) >= (step * minSize)):
                        if not (x0 == y0 == 0 and x1 == y1 == resolution):
                            w = x1 - x0
                            h = y1 - y0
                            coordsList.append([x0, y0, w, h])
    return np.array(coordsList)

def crop(dimension, start, end):
    def func(x):
        if dimension == 0:
            return x[start:end]
        elif dimension == 1:
            return x[:, start:end]
        elif dimension == 2:
            return x[:, :, start:end]
        elif dimension == 3:
            return x[:, :, :, start:end]
        elif dimension == 4:
            return x[:, :, :, :, start:end]
    return layers.Lambda(func)

def squeezefunc(x):
    return K.squeeze(x, axis=1)

def stackfunc(x):
    return K.stack(x, axis=1)

'''Model Setup'''
ROIS_resolution = 42
ROIS_grid_size = 3
min_grid_size = 2
pool_size = 7
loss_type = 'categorical_crossentropy'
metrics = ['accuracy']

base_model = Xception(weights='imagenet', input_tensor=layers.Input(shape=(image_size[0], image_size[1], 3)), include_top=False)
base_out = base_model.output
dims = base_out.shape[1:]
feat_dim = dims[-1] * pool_size * pool_size
base_channels = dims[-1]

x = squeeze_excite_block(base_out)
x_f = ConvSN2D(base_channels // 8, kernel_size=1, padding='same')(x)
x_g = ConvSN2D(base_channels // 8, kernel_size=1, padding='same')(x)
x_h = ConvSN2D(base_channels, kernel_size=1, padding='same')(x)
x_final = SelfAttention(filters=base_channels)([x, x_f, x_g, x_h])

full_img = layers.Lambda(lambda x: tf.image.resize(x, (ROIS_resolution, ROIS_resolution)), name='Lambda_img_1')(x_final)

rois_mat = getROIS(resolution=ROIS_resolution, gridSize=ROIS_grid_size, minSize=min_grid_size)
num_rois = rois_mat.shape[0]

roi_pool = RoiPoolingConv(pool_size=pool_size, num_rois=num_rois, rois_mat=rois_mat)(full_img)

jcvs = []
for j in range(num_rois):
    roi_crop = crop(1, j, j + 1)(roi_pool)
    x = layers.Lambda(squeezefunc, name=f'roi_lambda_{j
